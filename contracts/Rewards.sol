// SPDX-License-Identifier: GPL-3.0
pragma solidity =0.8.19;

import "./interfaces/IRewards.sol";
import "./interfaces/IStaker.sol";
import "./interfaces/IConverter.sol";
import "./interfaces/IRewardRouter.sol";
import "./interfaces/IRewardTracker.sol";
import "./interfaces/IERC20.sol";
import "./interfaces/IWETH.sol";
import "./interfaces/ITransferReceiver.sol";
import "./common/Adminable.sol";
import "./common/SafeERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "./common/Math.sol";
import "./common/Pausable.sol";

/**
 * @title Rewards
 * @author Key Finance
 * @notice
 * This contract allows users to query and claim rewards generated by staking GMXkey and MPkey.
 * Additionally, it includes various functions required for managing records related to reward settlement.
 * A notable example is the updateAllRewardsForTransferReceiverAndTransferFee function, which is called from the receiver contract.
 */
contract Rewards is IRewards, ReentrancyGuard, Pausable {
    using SafeERC20 for IERC20;

    // constants
    uint16 public constant FEE_RATE_BASE = 10000;
    uint16 public constant FEE_RATE_MAX = 2500;
    uint128 public constant PRECISION = 1e27;

    // external contracts
    address public immutable stakedGmxTracker;
    address public immutable feeGmxTracker;
    address public immutable esGmx;
    address public immutable bnGmx;
    address public immutable weth;

    // key protocol contracts & addresses
    address public immutable GMXkey;
    address public immutable MPkey;
    address public immutable staker;
    address public converter;
    address public treasury;

    // state variables
    mapping(address => mapping(address => uint256)) internal rewardPerUnit;
    mapping(address => mapping(address => mapping(address => uint256))) internal lastRewardPerUnit;
    mapping(address => mapping(address => mapping(address => uint256))) internal reward;
    mapping(address => mapping(address => uint256)) internal lastDepositBalancesForReceivers;
    mapping(address => uint16) public feeRate;
    mapping(address => mapping(address => uint256)) public cumulatedReward;
    mapping(address => mapping(address => uint16)) public claimFeeRate;

    constructor(address _admin, IRewardRouter _rewardRouter, address _GMXkey, address _MPkey, address _staker, address _treasury) Pausable(_admin) {
        require(address(_rewardRouter) != address(0), "Rewards: rewardRouter must not be zero address");
        require(_GMXkey != address(0), "Rewards: GMXkey must not be zero address");
        require(_MPkey != address(0), "Rewards: MPkey must not be zero address");
        require(_staker != address(0), "Rewards: staker must not be zero address");
        require(_treasury != address(0), "Rewards: treasury must not be zero address");
        stakedGmxTracker = _rewardRouter.stakedGmxTracker();
        require(stakedGmxTracker != address(0), "Rewards: stakedGmxTracker must not be zero address");
        feeGmxTracker = _rewardRouter.feeGmxTracker();
        require(feeGmxTracker != address(0), "Rewards: feeGmxTracker must not be zero address");
        esGmx = _rewardRouter.esGmx();
        require(esGmx != address(0), "Rewards: esGmx must not be zero address");
        bnGmx = _rewardRouter.bnGmx();
        require(bnGmx != address(0), "Rewards: bnGmx must not be zero address");
        GMXkey = _GMXkey;
        MPkey = _MPkey;
        weth = _rewardRouter.weth();
        require(weth != address(0), "Rewards: weth must not be zero address");
        staker = _staker;
        treasury = _treasury;
    }

    // - config functions - //
    
    // set treasury address
    function setTreasury(address _treasury) external onlyAdmin {
        require(_treasury != address(0), "Converter: treasury is the zero address");
        treasury = _treasury;
    }

    /**
     * Set the converter contract address.
     * @param _converter The converter contract address.
     */
    function setConverter(address _converter) external onlyAdmin {
        require(_converter != address(0), "Rewards: _converter must not be zero address");
        require(converter == address(0), "Rewards: converter must be not set yet");
        converter = _converter;
    }

    /**
     * Sets the fee amount to be paid to the account calling the reward settlement function for a specific receiver.
     * @param rewardToken The token type for which the fee will be applied. GMXkey, MPkey, and weth are all possible.
     * @param ratio Sets the amount of fee to be charged. It is set in 0.01% increments. 10000 = 100%
     */
    function setFeeRate(address rewardToken, uint16 ratio) external onlyAdmin {
        require(rewardToken == GMXkey || rewardToken == MPkey || rewardToken == weth, "Rewards: rewardToken must be GMXkey, MPkey, or weth");
        require(ratio <= FEE_RATE_BASE, "Rewards: ratio must be less than or equal to 10000");
        require(ratio <= FEE_RATE_MAX, "Rewards: ratio must be less than or equal to 2500");
        feeRate[rewardToken] = ratio;
    }

    /**
     * Sets the fee amount to be paid to the account calling the reward claim function for a specific account.
     * @param rewardToken The token type for which the fee will be applied. GMXkey, MPkey, and weth are all possible.
     * @param ratio Sets the amount of fee to be charged. It is set in 0.01% increments. 10000 = 100%
     */
    function setClaimFeeRate(address stakingToken, address rewardToken, uint16 ratio) external onlyAdmin {
        require(_isAvailablePairOfTokens(stakingToken, rewardToken), "Rewards: wrong pair of tokens (staking token, reward token)");
        require(ratio <= FEE_RATE_BASE, "Rewards: ratio must be less than or equal to 10000");
        require(ratio <= FEE_RATE_MAX, "Rewards: ratio must be less than or equal to 2500");
        claimFeeRate[stakingToken][rewardToken] = ratio;
    }

    // - external state-changing functions - //

    /**
     * Allows the user to claim rewards for 'account'.
     */
    function claimReward(address account) external nonReentrant whenNotPaused {
        _updateAccountReward(account);

        (uint256 gmxKeyAmount, uint256 gmxKeyFee) = _calculateAndClaimRewardAndFee(account, GMXkey, GMXkey);
        (uint256 mpKeyAmount, uint256 mpKeyFee) = _calculateAndClaimRewardAndFee(account, GMXkey, MPkey);
        (uint256 ethAmountFromGMXkey, uint256 ethFeeFromGMXkey) = _calculateAndClaimRewardAndFee(account, GMXkey, weth);
        (uint256 ethAmountFromMPkey, uint256 ethFeeFromMPkey) = _calculateAndClaimRewardAndFee(account, MPkey, weth);
        if (ethFeeFromGMXkey > 0 || ethFeeFromMPkey > 0) _transferAsETH(treasury, ethFeeFromGMXkey + ethFeeFromMPkey);
        if (ethAmountFromGMXkey > 0 || ethAmountFromMPkey > 0) _transferAsETH(account, ethAmountFromGMXkey + ethAmountFromMPkey);

        emit RewardClaimed(account, gmxKeyAmount, gmxKeyFee, mpKeyAmount, mpKeyFee, ethAmountFromGMXkey, ethFeeFromGMXkey, ethAmountFromMPkey, ethFeeFromMPkey);
    }

    // - external view functions - //

    /**
     * @notice Returns the claimable rewards for a given account.
     * @param account The account to check.
     * @return gmxkeyReward The claimable GMXkey reward.
     * @return mpkeyReward The claimable MPkey reward.
     * @return wethRewardForGMXkey The claimable WETH reward for GMXkey.
     * @return wethRewardForMPkey The claimable WETH reward for MPkey.
     */
    function claimableReward(address account) external view returns (uint256 gmxkeyReward, uint256 mpkeyReward, uint256 wethRewardForGMXkey, uint256 wethRewardForMPkey) {
        gmxkeyReward = reward[account][GMXkey][GMXkey] + _calculateReward(GMXkey, GMXkey, account);
        mpkeyReward = reward[account][GMXkey][MPkey] + _calculateReward(GMXkey, MPkey, account);
        wethRewardForGMXkey = reward[account][GMXkey][weth] + _calculateReward(GMXkey, weth, account);
        wethRewardForMPkey = reward[account][MPkey][weth] + _calculateReward(MPkey, weth, account);
    }

    // - external functions called by other key protocol contracts - //

    /**
     * @notice Initializes the last record for the receiver's deposit balance for esGmx and bnGmx.
     */
    function initTransferReceiver() external {
        require(IConverter(converter).receiverActiveAt(msg.sender) > 0, "Rewards: receiver is invalid");
        require(!ITransferReceiver(msg.sender).accepted(), "Rewards: receiver has already accepted the transfer");
        uint256 stakedEsGmxAmount = IRewardTracker(stakedGmxTracker).depositBalances(msg.sender, esGmx);
        lastDepositBalancesForReceivers[msg.sender][esGmx] = stakedEsGmxAmount;
        uint256 stakedMpAmount = IRewardTracker(feeGmxTracker).depositBalances(msg.sender, bnGmx);
        lastDepositBalancesForReceivers[msg.sender][bnGmx] = stakedMpAmount;
        emit ReceiverInitialized(msg.sender, stakedEsGmxAmount, stakedMpAmount);
    }

    /**
     * @notice Updates the rewards for the given account.
     * @dev This function is called when staking/unstaking GMXkey or MPkey.
     * @param account The account to update.
     */
    function updateRewards(address account, address stakingToken) external {
        require(account != address(0), "Rewards: updateRewards from the zero address");
        require(msg.sender == staker, "Rewards: only staker can call this function");
        _updateAccountReward(account, stakingToken);
    }

    /**
     * @notice Updates all rewards for the transfer receiver contract and transfers the fees.
     * This function mints GMXkey & MPkey, updates common reward-related values,
     * and updates the receiver's value and records for future calls.
     * @dev Allows anyone to call this for a later upgrade of the transfer receiver contract,
     * which might enable anyone to update all rewards & receive fees.
     * @param receiver The receiver contract from which the rewards originate.
     */
    function updateAllRewardsForTransferReceiverAndTransferFee(address receiver, address feeTo) external nonReentrant whenNotPaused {
        require(IConverter(converter).isActiveReceiver(receiver) && ITransferReceiver(receiver).accepted(), "Rewards: only transferFeeReceiver can be used for this function");
        uint256 gmxKeyAmountToMint = _updateNonEthRewardsForTransferReceiverAndTransferFee(receiver, GMXkey, feeTo); // GMXkey
        uint256 mpKeyAmountToMint = _updateNonEthRewardsForTransferReceiverAndTransferFee(receiver, MPkey, feeTo); // MPkey
        uint256 wethAmountToTransfer = _updateWethRewardsForTransferReceiverAndTransferFee(receiver, feeTo);
        emit RewardsCalculated(receiver, gmxKeyAmountToMint, mpKeyAmountToMint, wethAmountToTransfer);
    }

    // - internal functions - //

    /**
     * Return true if pair of the tokens (staking token, reward token) exists
     */
    function _isAvailablePairOfTokens(address stakingToken, address rewardToken) internal view returns (bool) {
        if (stakingToken == GMXkey) {
            return rewardToken == GMXkey || rewardToken == MPkey || rewardToken == weth;
        }
        return stakingToken == MPkey && rewardToken == weth;
    }

    /**
     * Calculate fee from 'reward' variable and transfer reward & fee if 'isNonWeth' parameter is true
     */
    function _calculateAndClaimRewardAndFee(address account, address stakingToken, address rewardToken) internal returns (uint256 amount, uint256 fee) {
        amount = reward[account][stakingToken][rewardToken];
        if (amount > 0) {
            reward[account][stakingToken][rewardToken] = 0;
            fee = amount * claimFeeRate[stakingToken][rewardToken] / FEE_RATE_BASE;
            amount -= fee;
            if (rewardToken != weth) { // if it's weth, weth rewards from 'GMXkey' and 'MPkey' will be transferred together
                if (fee > 0) IERC20(rewardToken).safeTransfer(treasury, fee);
                IERC20(rewardToken).safeTransfer(account, amount);
            }
        }
    }

    /**
     * Updates the account's reward when it's not a target of earning cumulatedReward.
     */
    function _updateAccountReward(address account) internal {
        _updateAccountReward(account, address(0));
    }

    /**
     * Updates the account's reward.
     */
    function _updateAccountReward(address account, address stakingToken) internal {
        if (stakingToken == GMXkey) {
            _applyCumulatedReward(account, GMXkey, GMXkey);
            _applyCumulatedReward(account, GMXkey, MPkey);
            _applyCumulatedReward(account, GMXkey, weth);
        } else if (stakingToken == MPkey) {
            _applyCumulatedReward(account, MPkey, weth);
        }
        _updateAccountRewardForStakingTokenAndRewardToken(account, GMXkey, GMXkey);
        _updateAccountRewardForStakingTokenAndRewardToken(account, GMXkey, MPkey);
        _updateAccountRewardForStakingTokenAndRewardToken(account, GMXkey, weth);
        _updateAccountRewardForStakingTokenAndRewardToken(account, MPkey, weth);
    }

    /**
     * Applies the cumulated reward to the account's reward. This happens when any account stakes for the first time in a situation where 0 is staked.
     */
    function _applyCumulatedReward(address account, address stakingToken, address rewardToken) internal {
        if (cumulatedReward[stakingToken][rewardToken] > 0) {
            reward[account][stakingToken][rewardToken] += cumulatedReward[stakingToken][rewardToken];
            cumulatedReward[stakingToken][rewardToken] = 0;
        }
    }

    /**
     * Updates the account's reward & other reward-related values for the specified staking token and reward token.
     */
    function _updateAccountRewardForStakingTokenAndRewardToken(address account, address stakingToken, address rewardToken) internal {
        if (IStaker(staker).balance(stakingToken, account) > 0) {
            uint256 delta = _calculateReward(stakingToken, rewardToken, account);
            if (delta > 0) {
                reward[account][stakingToken][rewardToken] += delta;
            }
        }
        lastRewardPerUnit[account][stakingToken][rewardToken] = rewardPerUnit[stakingToken][rewardToken];
    }

    /**
     * Calculates the reward for the specified staking token and reward token that is claimable by the account.
     */
    function _calculateReward(address stakingToken, address rewardToken, address account) internal view returns (uint256) {
        return Math.mulDiv(rewardPerUnit[stakingToken][rewardToken] - lastRewardPerUnit[account][stakingToken][rewardToken], IStaker(staker).balance(stakingToken, account), PRECISION);
    }

    /**
     * Updates the non-ETH rewards from the transfer receiver contract & transfer fee.
     * @param receiver The receiver contract from which the rewards originate.
     * @param rewardToken The reward token to update.
     */
    function _updateNonEthRewardsForTransferReceiverAndTransferFee(address receiver, address rewardToken, address feeTo) internal returns (uint256 amountToMint) {
        uint256 _depositBalance = _getDepositBalancesForReceiver(receiver, rewardToken);
        uint256 _lastDepositBalance = lastDepositBalancesForReceivers[receiver][_getStakedToken(rewardToken)];
        if (_depositBalance > _lastDepositBalance) {
            amountToMint = _depositBalance - _lastDepositBalance;
            // Update receiver's value & records for later call
            lastDepositBalancesForReceivers[receiver][_getStakedToken(rewardToken)] = _depositBalance;
            // Update common reward-related values
            (uint256 amount, uint256 fee) = _calculateFee(amountToMint, feeRate[rewardToken]);
            _updateNonSharedReward(GMXkey, rewardToken, amount, IStaker(staker).totalBalance(GMXkey));
            IERC20(rewardToken).mint(address(this), amount);
            IERC20(rewardToken).mint(feeTo, fee);
        }
    }

    /**
     * Updates the WETH rewards from the transfer receiver contract & transfer fee.
     * @param receiver The receiver contract from which the rewards originate.
     */
    function _updateWethRewardsForTransferReceiverAndTransferFee(address receiver, address feeTo) internal returns (uint256 amountToTransfer) {
        amountToTransfer = IERC20(weth).allowance(receiver, address(this)); // use allowance to prevent 'weth transfer attack' by transferring any amount of weth to the receiver contract
        if (amountToTransfer > 0) {
            IERC20(weth).safeTransferFrom(receiver, address(this), amountToTransfer);
            // Update common reward-related values
            (uint256 amount, uint256 fee) = _calculateFee(amountToTransfer, feeRate[weth]);
            _updateWethReward(amount, receiver);
            if (fee > 0) _transferAsETH(feeTo, fee);
        }
    }

    /**
     * Records the calculated reward amount per unit staking amount.
     * @param stakingToken Staked token
     * @param rewardToken Token paid as a reward
     * @param amount Total claimable reward amount
     * @param totalBalance Total staking amount of stakingToken
     */
    function _updateNonSharedReward(address stakingToken, address rewardToken, uint256 amount, uint256 totalBalance) internal {
        if (totalBalance == 0) {
            cumulatedReward[stakingToken][rewardToken] += amount;
        } else {
            rewardPerUnit[stakingToken][rewardToken] += Math.mulDiv(amount, PRECISION, totalBalance);
        }
    }

    /**
     * @notice Records the reward amount per unit staking amount for WETH rewards paid to both GMXkey and MPkey.
     * @dev In the case of WETH rewards paid to both GMXkey and MPkey, the reward amount for each cannot be known. 
     * Therefore, they are calculated together at once.
     * @param amount Total claimable WETH amount
     */
    function _updateWethReward(uint256 amount, address receiver) internal {
        uint256 _mpKeyTotalBalance = IStaker(staker).totalBalance(MPkey);
        if (ITransferReceiver(receiver).isForMpKey()) {
            _updateNonSharedReward(MPkey, weth, amount, _mpKeyTotalBalance);
            return;
        }
        uint256 panGmxStaked = IRewardTracker(stakedGmxTracker).stakedAmounts(receiver);
        uint256 mpStaked = IRewardTracker(feeGmxTracker).depositBalances(receiver, bnGmx);
        uint256 amountForMpKey = Math.mulDiv(amount, mpStaked, panGmxStaked + mpStaked);
        uint256 amountForGmxKey = amount - amountForMpKey;
        uint256 _gmxKeyTotalBalance = IStaker(staker).totalBalance(GMXkey);
        _updateNonSharedReward(GMXkey, weth, amountForGmxKey, _gmxKeyTotalBalance);
        _updateNonSharedReward(MPkey, weth, amountForMpKey, _mpKeyTotalBalance);
    }

    /**
     * Queries the staking amount of the token corresponding to the rewardToken.
     * @param receiver The receiver contract targeted to check how much stakingToken has been accumulated for the given rewardToken.
     * @param rewardToken Which rewardToken's stakingToken amount is being queried.
     */
    function _getDepositBalancesForReceiver(address receiver, address rewardToken) internal view returns (uint256) {
        if (rewardToken == GMXkey) {
            return IRewardTracker(stakedGmxTracker).depositBalances(receiver, _getStakedToken(rewardToken));
        } else { // rewardToken == MPkey
            return IRewardTracker(feeGmxTracker).depositBalances(receiver, _getStakedToken(rewardToken));
        }
    }

    /**
     * Queries the token staked at GMX protocol, corresponding to the rewardToken.
     */
    function _getStakedToken(address rewardToken) internal view returns (address) {
        if (rewardToken == GMXkey) {
            return esGmx;
        } else { // rewardToken == MPkey
            return bnGmx;
        } 
    }

    /**
     * Calculates the reward amount after fee transfer and its fee.
     */
    function _calculateFee(uint256 amount, uint256 _feeRate) internal pure returns (uint256, uint256) {
        uint256 fee = amount * _feeRate / FEE_RATE_BASE;
        return (amount - fee, fee);
    }

    /**
     * Transfers the specified amount as ETH to the specified address.
     */
    function _transferAsETH(address to, uint256 amount) internal {
        // amount is already non-zero

        IWETH(weth).withdraw(amount);
        (bool success, ) = to.call{ value: amount }("");
        require(success, "Transfer failed");
    }

    receive() external payable {}
}